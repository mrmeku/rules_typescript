/* Copyright 2016 The Bazel Authors. All rights reserved.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package rules

import (
	"fmt"
	"log"
	"path"
	"strings"

	bf "github.com/bazelbuild/buildtools/build"
	"github.com/bazelbuild/rules_typescript/tools/taze/config"
	"github.com/bazelbuild/rules_typescript/tools/taze/packages"
	"github.com/bazelbuild/rules_typescript/tools/taze/resolve"
)

// NewGenerator returns a new instance of Generator.
// "buildRel" is a slash-separated path to the directory containing the
// build file being generated, relative to the repository root.
// "oldFile" is the existing build file. May be nil.
func NewGenerator(c *config.Config, l resolve.Labeler, buildRel string, oldFile *bf.File) *Generator {
	shouldSetVisibility := oldFile == nil || !hasDefaultVisibility(oldFile)
	return &Generator{c: c, l: l, buildRel: buildRel, shouldSetVisibility: shouldSetVisibility}
}

// Generator generates Bazel build rules for Go build targets.
type Generator struct {
	c                   *config.Config
	l                   resolve.Labeler
	buildRel            string
	shouldSetVisibility bool
}

// GenerateRules generates a list of rules for targets in "pkg". It also returns
// a list of empty rules that may be deleted from an existing file.
func (g *Generator) GenerateRules(pkg *packages.Package) (rules []bf.Expr, empty []bf.Expr) {
	var rs []bf.Expr

	rs = append(rs,
		g.generateTest(pkg, "", true))

	for _, r := range rs {
		if isEmpty(r) {
			empty = append(empty, r)
		} else {
			rules = append(rules, r)
		}
	}
	return rules, empty
}

func (g *Generator) generateLib(pkg *packages.Package, goProtoName string) (string, *bf.CallExpr) {
	name := g.l.LibraryLabel(pkg.Rel).Name
	if !pkg.Library.HasGo() && goProtoName == "" {
		return "", emptyRule("go_library", name)
	}
	var visibility string
	if pkg.IsCommand() {
		// Libraries made for a go_binary should not be exposed to the public.
		visibility = "//visibility:private"
	} else {
		visibility = checkInternalVisibility(pkg.Rel, "//visibility:public")
	}

	attrs := g.commonAttrs(pkg.Rel, name, visibility, pkg.Library)
	attrs = append(attrs, keyvalue{"importpath", pkg.ImportPath(g.c.GoPrefix)})
	if goProtoName != "" {
		attrs = append(attrs, keyvalue{"embed", []string{":" + goProtoName}})
	}

	rule := newRule("go_library", attrs)
	return name, rule
}

// hasDefaultVisibility returns whether oldFile contains a "package" rule with
// a "default_visibility" attribute. Rules generated by Taze should not
// have their own visibility attributes if this is the case.
func hasDefaultVisibility(oldFile *bf.File) bool {
	for _, s := range oldFile.Stmt {
		c, ok := s.(*bf.CallExpr)
		if !ok {
			continue
		}
		r := bf.Rule{c}
		if r.Kind() == "package" && r.Attr("default_visibility") != nil {
			return true
		}
	}
	return false
}

// checkInternalVisibility overrides the given visibility if the package is
// internal.
func checkInternalVisibility(rel, visibility string) string {
	if i := strings.LastIndex(rel, "/internal/"); i >= 0 {
		visibility = fmt.Sprintf("//%s:__subpackages__", rel[:i])
	} else if strings.HasPrefix(rel, "internal/") {
		visibility = "//:__subpackages__"
	}
	return visibility
}

func (g *Generator) generateTest(pkg *packages.Package, library string, isXTest bool) bf.Expr {
	name := g.l.TestLabel(pkg.Rel, isXTest).Name
	target := pkg.Test
	importpath := pkg.ImportPath(g.c.GoPrefix)
	if isXTest {
		target = pkg.XTest
		importpath += "_test"
	}
	if !target.HasGo() {
		return emptyRule("go_test", name)
	}
	attrs := g.commonAttrs(pkg.Rel, name, "", target)
	// TODO(jayconrod): don't add importpath if it can be inherited from library.
	// This is blocked by bazelbuild/bazel#3575.
	attrs = append(attrs, keyvalue{"importpath", importpath})
	if library != "" {
		attrs = append(attrs, keyvalue{"embed", []string{":" + library}})
	}
	if pkg.HasTestdata {
		glob := globvalue{patterns: []string{path.Join(g.buildPkgRel(pkg.Rel), "testdata/**")}}
		attrs = append(attrs, keyvalue{"data", glob})
	}
	if g.c.StructureMode == config.FlatMode {
		attrs = append(attrs, keyvalue{"rundir", pkg.Rel})
	}
	return newRule("go_test", attrs)
}

func (g *Generator) commonAttrs(pkgRel, name, visibility string, target packages.GoTarget) []keyvalue {
	attrs := []keyvalue{{"name", name}}
	if !target.Sources.IsEmpty() {
		attrs = append(attrs, keyvalue{"srcs", g.sources(target.Sources, pkgRel)})
	}
	if g.shouldSetVisibility && visibility != "" {
		attrs = append(attrs, keyvalue{"visibility", []string{visibility}})
	}
	imports := target.Imports
	imports.Clean()
	if !imports.IsEmpty() {
		attrs = append(attrs, keyvalue{config.TazeImportsKey, imports})
	}
	return attrs
}

// sources converts paths in "srcs" which are relative to the Go package
// directory ("pkgRel") into relative paths to the build file
// being generated ("g.buildRel").
func (g *Generator) sources(srcs packages.PlatformStrings, pkgRel string) packages.PlatformStrings {
	if g.buildRel == pkgRel {
		return srcs
	}
	rel := g.buildPkgRel(pkgRel)
	srcs, _ = srcs.Map(func(s string) (string, error) {
		return path.Join(rel, s), nil
	})
	return srcs
}

// buildPkgRel returns the relative slash-separated path from the directory
// containing the build file (g.buildRel) to the Go package directory (pkgRel).
// pkgRel must start with g.buildRel.
func (g *Generator) buildPkgRel(pkgRel string) string {
	if g.buildRel == pkgRel {
		return ""
	}
	if g.buildRel == "" {
		return pkgRel
	}
	rel := strings.TrimPrefix(pkgRel, g.buildRel+"/")
	if rel == pkgRel {
		log.Panicf("relative path to go package %s must start with relative path to Bazel package %s", pkgRel, g.buildRel)
	}
	return rel
}

func isEmpty(r bf.Expr) bool {
	c, ok := r.(*bf.CallExpr)
	return ok && len(c.List) == 1 // name
}
