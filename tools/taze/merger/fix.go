/* Copyright 2017 The Bazel Authors. All rights reserved.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package merger

import (
	bf "github.com/bazelbuild/buildtools/build"
	"github.com/bazelbuild/rules_typescript/tools/taze/config"
)

// Much of this file could be simplified by using
// github.com/bazelbuild/buildtools/edit. However, through a transitive
// dependency, that library depends on a proto in Bazel itself, which is
// a 95MB download. Not worth it.

// FixFile updates rules in oldFile that were generated by an older version of
// Taze to a newer form that can be merged with freshly generated rules.
//
// FixImports should be called after this, since it will fix load
// statements that may be broken by transformations applied by this function.
func FixFile(c *config.Config, oldFile *bf.File) *bf.File {
	return oldFile
}

// squashExpr combines two expressions. Unlike mergeExpr, squashExpr does not
// discard information from an "old" expression. It does not sort or de-duplicate
// elements. The following kinds of expressions are recognized:
//
//   * nil
//   * lists
//   * calls to select with a dict argument. The dict keys must be strings,
//     and the values must be lists.
//   * lists combined with select using +. The list must be the left operand.
func squashExpr(x, y bf.Expr) (bf.Expr, error) {
	xList, xDict, err := exprListAndDict(x)
	if err != nil {
		return nil, err
	}
	yList, yDict, err := exprListAndDict(y)
	if err != nil {
		return nil, err
	}

	squashedList := squashList(xList, yList)
	squashedDict, err := squashDict(xDict, yDict)
	if err != nil {
		return nil, err
	}

	var squashedSelect bf.Expr
	if squashedDict != nil {
		squashedSelect = &bf.CallExpr{
			X:    &bf.LiteralExpr{Token: "select"},
			List: []bf.Expr{squashedDict},
		}
	}

	if squashedList == nil {
		return squashedDict, nil
	}
	if squashedSelect == nil {
		return squashedList, nil
	}
	return &bf.BinaryExpr{
		X:  squashedList,
		Op: "+",
		Y:  squashedSelect,
	}, nil
}

func squashList(x, y *bf.ListExpr) *bf.ListExpr {
	if x == nil {
		return y
	}
	if y == nil {
		return x
	}
	squashed := *x
	squashed.Comments.Before = append(x.Comments.Before, y.Comments.Before...)
	squashed.Comments.Suffix = append(x.Comments.Suffix, y.Comments.Suffix...)
	squashed.Comments.After = append(x.Comments.After, y.Comments.After...)
	squashed.List = append(x.List, y.List...)
	return &squashed
}

func squashDict(x, y *bf.DictExpr) (*bf.DictExpr, error) {
	if x == nil {
		return y, nil
	}
	if y == nil {
		return x, nil
	}

	squashed := *x
	squashed.Comments.Before = append(x.Comments.Before, y.Comments.Before...)
	squashed.Comments.Suffix = append(x.Comments.Suffix, y.Comments.Suffix...)
	squashed.Comments.After = append(x.Comments.After, y.Comments.After...)

	xCaseIndex := make(map[string]int)
	for i, e := range x.List {
		kv, ok := e.(*bf.KeyValueExpr)
		if !ok {
			continue
		}
		key, ok := kv.Key.(*bf.StringExpr)
		if !ok {
			continue
		}
		xCaseIndex[key.Value] = i
	}

	for _, e := range y.List {
		kv, ok := e.(*bf.KeyValueExpr)
		if !ok {
			squashed.List = append(squashed.List, e)
			continue
		}
		key, ok := e.(*bf.StringExpr)
		if !ok {
			squashed.List = append(squashed.List, e)
			continue
		}
		i, ok := xCaseIndex[key.Value]
		if !ok {
			squashed.List = append(squashed.List, e)
			continue
		}
		squashedElem, err := squashExpr(x.List[i], kv.Value)
		if err != nil {
			return nil, err
		}
		x.List[i] = squashedElem
	}

	return &squashed, nil
}

// FixFileMinor updates rules in oldFile that were generated by an older version
// of Taze to a newer form that can be merged with freshly generated rules.
//
// FixFileMinor includes only small, low-risk fixes that can be applied in
// update mode. When both FixFileMinor and FixFile are called, FixFileMinor
// should be called first.
//
// FixImports should be called after this, since it will fix load
// statements that may be broken by transformations applied by this function.
func FixFileMinor(c *config.Config, oldFile *bf.File) *bf.File {
	return oldFile
}

// FixImports removes imports of unused go rules and adds imports of newly used rules.
// This should be called after FixFile and MergeWithExisting, since symbols
// may be introduced that aren't imported.
func FixImports(oldFile *bf.File) *bf.File {
	// Make a list of import statements in the file. Keep track of imports of known
	// files, since these may be changed. Keep track of known symbols imported from
	// unknown files; we will not add imports for these.
	type loadInfo struct {
		index      int
		file       string
		old, fixed *bf.CallExpr
	}
	var imports []loadInfo
	otherimportedKinds := make(map[string]bool)
	for i, stmt := range oldFile.Stmt {
		c, ok := stmt.(*bf.CallExpr)
		if !ok {
			continue
		}
		x, ok := c.X.(*bf.LiteralExpr)
		if !ok || x.Token != "load" {
			continue
		}

		if len(c.List) == 0 {
			continue
		}
		label, ok := c.List[0].(*bf.StringExpr)
		if !ok {
			continue
		}

		if knownFiles[label.Value] {
			imports = append(imports, loadInfo{index: i, file: label.Value, old: c})
			continue
		}
		for _, arg := range c.List[1:] {
			switch sym := arg.(type) {
			case *bf.StringExpr:
				otherimportedKinds[sym.Value] = true
			case *bf.BinaryExpr:
				if sym.Op != "=" {
					continue
				}
				if x, ok := sym.X.(*bf.LiteralExpr); ok {
					otherimportedKinds[x.Token] = true
				}
			}
		}
	}

	// Make a map of all the symbols from known files used in this file.
	usedKinds := make(map[string]map[string]bool)
	for _, stmt := range oldFile.Stmt {
		c, ok := stmt.(*bf.CallExpr)
		if !ok {
			continue
		}
		x, ok := c.X.(*bf.LiteralExpr)
		if !ok {
			continue
		}

		kind := x.Token
		if file, ok := knownKinds[kind]; ok && !otherimportedKinds[kind] {
			if usedKinds[file] == nil {
				usedKinds[file] = make(map[string]bool)
			}
			usedKinds[file][kind] = true
		}
	}

	// Fix the import statements. The order is important, so we iterate over
	// knownImports instead of knownFiles.
	changed := false
	var newFirstimports []*bf.CallExpr
	for _, l := range knownImports {
		file := l.file
		first := true
		for i, _ := range imports {
			li := &imports[i]
			if li.file != file {
				continue
			}
			if first {
				li.fixed = fixImport(li.old, file, usedKinds[file])
				first = false
			} else {
				li.fixed = fixImport(li.old, file, nil)
			}
			changed = changed || li.fixed != li.old
		}
		if first {
			load := fixImport(nil, file, usedKinds[file])
			if load != nil {
				newFirstimports = append(newFirstimports, load)
				changed = true
			}
		}
	}
	if !changed {
		return oldFile
	}

	// Rebuild the file.
	fixedFile := *oldFile
	fixedFile.Stmt = make([]bf.Expr, 0, len(oldFile.Stmt)+len(newFirstimports))
	for _, l := range newFirstimports {
		fixedFile.Stmt = append(fixedFile.Stmt, l)
	}
	loadIndex := 0
	for i, stmt := range oldFile.Stmt {
		if loadIndex < len(imports) && i == imports[loadIndex].index {
			if imports[loadIndex].fixed != nil {
				fixedFile.Stmt = append(fixedFile.Stmt, imports[loadIndex].fixed)
			}
			loadIndex++
			continue
		}
		fixedFile.Stmt = append(fixedFile.Stmt, stmt)
	}
	return &fixedFile
}

// knownImports is a list of files Taze will generate imports from and
// the symbols it knows about.  All symbols Taze ever generated
// imports for are present, including symbols it no longer uses (e.g.,
// cgo_library). Manually imported symbols (e.g., run time dependencies) are not
// included. The order of the files here will match the order of
// generated import statements. The symbols should be sorted
// lexicographically.
var knownImports = []struct {
	file  string
	kinds []string
}{
	{
		"@build_bazel_rules_typescript//:defs.bzl",
		[]string{
			"ts_library",
		},
	},
}

// knownFiles is the set of labels for files that Taze imports symbols from.
var knownFiles map[string]bool

// knownKinds is a map from symbols to labels of the files they are imported
// from.
var knownKinds map[string]string

func init() {
	knownFiles = make(map[string]bool)
	knownKinds = make(map[string]string)
	for _, l := range knownImports {
		knownFiles[l.file] = true
		for _, k := range l.kinds {
			knownKinds[k] = l.file
		}
	}
}

// fixImport updates a import statement. load must be a import statement for
// the Go rules or nil. If nil, a new statement may be created. Symbols in
// kinds are added if they are not already present, symbols in knownKinds
// are removed if they are not in kinds, and other symbols and arguments
// are preserved. nil is returned if the statement should be deleted because
// it is empty.
func fixImport(importStatement *bf.CallExpr, file string, kinds map[string]bool) *bf.CallExpr {
	return importStatement
}

type byString []*bf.StringExpr

func (s byString) Len() int {
	return len(s)
}

func (s byString) Less(i, j int) bool {
	return s[i].Value < s[j].Value
}

func (s byString) Swap(i, j int) {
	s[i], s[j] = s[j], s[i]
}

func isTypeScriptRule(kind string) bool {
	return kind == "ts_library" || kind == "ts_config"
}
